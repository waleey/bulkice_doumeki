#include "OMSimEventAction.hh"
#include "OMSimTrackingAction.hh"
#include "OMSimRunAction.hh"
#include "G4TrackingManager.hh"
#include "G4Track.hh"
#include "G4ThreeVector.hh"
#include "G4SystemOfUnits.hh"
#include "OMSimRadioactivityData.hh"
#include "G4ParticleTable.hh"

OMSimTrackingAction::OMSimTrackingAction()
:G4UserTrackingAction(), counter(0)
{
   // ftrackingManager = new G4TrackingManager();
}

OMSimTrackingAction::~OMSimTrackingAction()
{
}

void OMSimTrackingAction::PreUserTrackingAction(const G4Track* aTrack)
{
    /**
    *temporal correlation between parent and daughter nucleus is preserved
    *if the mean life time of daughter nucleus is within the time window
    *if not, the decay time of the daughter is set to a random time t_rnd
    * drawn from a flat distribution between [o, t_window]
    *and the daughter is forced to decay immediately with initial time t_rnd
    *This is necessary to maintain the secular equilibrium
    *among the nucleus in the decay chain of each isotope.
    **/
    G4double timeWindow = OMSimRadioactivityData::ftimeWindow * s;
    OMSimRadioactivityData* radData = new OMSimRadioactivityData();
    if(aTrack -> GetCreatorProcess())
    {
           // check if particle is instabel
           if(!(aTrack -> GetParticleDefinition() -> GetPDGStable()))
            {  

                std::cout << aTrack -> GetParticleDefinition()->GetParticleName()
                          << " Mean Life Time [ns] : "
                          << aTrack -> GetParticleDefinition()->GetPDGLifeTime()   
                          << std::endl; 

                // check if mean decay time is larger than time window
                if(aTrack -> GetParticleDefinition() -> GetPDGLifeTime() > OMSimRadioactivityData::ftimeWindow * s )
                {   
                    // Remove the const qualifier to make the track modifiable
                    G4Track* mTrack = const_cast<G4Track*>(aTrack);

                    // set random global time
                    double randGlobalTime = radData -> GetInitialTime();
                    mTrack -> SetGlobalTime(randGlobalTime * s);

                    std::cout << "Parent " << aTrack->GetParticleDefinition()->GetParticleName()
                              << " assigned random Global Time: " << randGlobalTime << " ns." << std::endl;

                    
                    // temporarily set lifetime to zero to force immediate decay
                    double originalLifeTime = mTrack -> GetDefinition() -> GetPDGLifeTime();

                    // Store the original lifetime for restoration in PostUserTrackingAction
                    fOriginalLifeTimes[mTrack->GetDefinition()] = originalLifeTime;

                    // let daughter decay immediately
                    mTrack -> GetDefinition() -> SetPDGLifeTime(0. * ns);
            
                }
                else
                {
                    
                }

                /**
                std::cout << aTrack -> GetParticleDefinition()->GetParticleName()
                        << " Global Time [ns] : " 
                        << aTrack -> GetGlobalTime()
                        << std::endl; 
                **/
            }

    }
    delete radData;
}

void OMSimTrackingAction::PostUserTrackingAction(const G4Track* aTrack)
{
    // Check if the particle definition had its lifetime temporarily changed
    auto it = fOriginalLifeTimes.find(aTrack->GetParticleDefinition());
    if (it != fOriginalLifeTimes.end()) {

        // remove const qualifier from GetParticleDefinition
        G4ParticleDefinition* mParticleDefinition = const_cast<G4ParticleDefinition*>(aTrack->GetParticleDefinition());

        // Restore the original lifetime
        mParticleDefinition -> SetPDGLifeTime(it->second);

        // Remove the entry from the map
        fOriginalLifeTimes.erase(it);

        std::cout << "Restored lifetime for "
                  << aTrack->GetParticleDefinition()->GetParticleName()
                  << " to " << it->second << " ns." << std::endl;
    }


    // Access and modify secondaries
    const auto* secondaries = fpTrackingManager->GimmeSecondaries();
    if (secondaries)
    {
        for (size_t i = 0; i < secondaries->size(); ++i)
        {

            G4Track* secondaryTrack = (*secondaries)[i];
            const G4ParticleDefinition* particleDef = secondaryTrack->GetParticleDefinition();

            // Check if the particle is unstable
            if (!(particleDef->GetPDGStable()))
            {
                G4double meanLifeTime = particleDef->GetPDGLifeTime();
                
                // Case 1: Short-lived secondary (mean life < simulation time window)
                if (meanLifeTime <= OMSimRadioactivityData::ftimeWindow * s)
                {
                    secondaryTrack->SetGlobalTime(aTrack->GetGlobalTime());  // Match parent's time
                    std::cout << "Short-lived secondary " 
                            << particleDef->GetParticleName()
                            << " Global Time synced with parent: " 
                            << secondaryTrack->GetGlobalTime() << " ns." << std::endl;
                }
                // Case 2: Long-lived secondary (mean life > simulation time window)
                else
                {
                    // Retain the random global time set in PreUserTrackingAction for forced decay
                    std::cout << "Long-lived secondary " 
                            << particleDef->GetParticleName()
                            << " retains Global Time: " 
                            << secondaryTrack->GetGlobalTime() << " ns." << std::endl;
                }
            }
        }
    }

    /*G4TrackVector* secTracks = ftrackingManager -> GimmeSecondaries();
    size_t n_secondaries = (*secTracks).size();
    G4cout << "SIZE " << n_secondaries << G4endl;
   if(secTracks)
    {
        for(size_t i = 0; i < n_secondaries; i++)
        {
            if((*secTracks)[i] -> GetDefinition() == G4OpticalPhoton::Definition())
            {
                counter++;
            }
        }
    }

    G4cout << "***********Total Number of Secondary Produced: " << counter << " **************" << G4endl;*/
}
